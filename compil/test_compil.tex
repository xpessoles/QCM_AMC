\documentclass[a4paper]{article}

% bloc : évite un changement de page
% completemulti : ajoute une case : aucune bonne réponse
%\newcommand{\repRel}{../..}
%\input{\repRel/Style/packages}
%%\input{\repRel/Style/new_style}
%\input{\repRel/Style/macros_SII}
%%\input{\repRel/Style/environment}

%\usepackage[francais,bloc,completemulti,ensemble]{automultiplechoice}
\usepackage[francais,bloc,completemulti,catalog]{automultiplechoice} %ensemble
\usepackage{multicol}

%% Pour le python %%
\usepackage{listingsutf8}

\lstset{language=Python,
  inputencoding=utf8/latin1,
  breaklines=true,
  basicstyle=\ttfamily\small,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
  upquote = true,
  columns=fullflexible,
  backgroundcolor=\color{gray!10},frame=leftline,rulecolor=\color{gray}}  
  
\definecolor{mygreen}{rgb}{0,0.6,0}

\lstset{
     literate=%
         {é}{{\'e}}1    
         {è}{{\`e}}1    
         {ê}{{\^e}}1    
         {à}{{\`a}}1
         {â}{{\^a}}1		 
         {ô}{{\^o}}1    
         {ù}{{\`u}}1    
         {î}{{\^i}}1    
}
\lstset{inputpath=code}

%\usepackage[utf8x]{inputenc}
%\usepackage[T1]{fontenc}

\begin{document}


\element{OperationsElementaires}{
\begin{question}{OpEl01}% genumsi nreveret
	On souhaite écrire un programme calculant le triple d'un nombre décimal et affichant le résultat. On a saisi le code suivant :
	\lstinputlisting{OpEl_01.py}
	Quel va être le résultat affiché ?
\begin{multicols}{4}
	\begin{reponses}	
	\bonne{555}
	\mauvaise{\lstinline{nombrenombrenombre}}
	\mauvaise{\lstinline{15}}
	\mauvaise{\lstinline{15.0}}
	\end{reponses}
	\end{multicols}
\end{question}

\begin{question}{OpEl02} % nreveret
	On a saisi le code suivant : 
	\lstinputlisting{OpEl_02.py}
\begin{multicols}{4}	
	\begin{reponses}	
	\bonne{\lstinline{print(a + ' = ' + c)}}
	\mauvaise{\lstinline{print(a + ' = ' + d)}}
	\mauvaise{\lstinline{print(b + ' = ' + c)}}
	\mauvaise{\lstinline{print(b + ' = ' + d)}}
	\end{reponses}
	\end{multicols}
\end{question}



\begin{question}{}%

\begin{multicols}{4}	
	\begin{reponses}	
	\bonne{}
	\mauvaise{}
	\mauvaise{}
	\mauvaise{}
	\end{reponses}
	\end{multicols}
\end{question}
}


\element{OperationsArithmetiques}{
\begin{question}{OpAr01}
	On exécute l'instruction ci-après. Quel est l'affichage attendu ?
	\lstinputlisting{oparith01.py}
	\begin{multicols}{4}
	\begin{reponses}	
	\bonne{0}
	\mauvaise{1}
	\mauvaise{2}
	\mauvaise{4}
	\end{reponses}
	\end{multicols}
\end{question}}


\element{CodageEntiers}{
\begin{question}{entiers 01} % genumsi nreveret
	Quel est l'entier positif codé en base 2 sur 8 bits par le code 0011 1010 ?
	\begin{multicols}{4}
	\begin{reponses}	
	\bonne{58}
	\mauvaise{45}
	\mauvaise{25}
	\mauvaise{-12}
	\end{reponses}
	\end{multicols}
\end{question}

\begin{question}{entiers 02} % genumsi nreveret
	Le résultat de l'addition des deux nombres binaires 1101 et 0101 est:
	\begin{multicols}{4}
	\begin{reponses}	
	\bonne{10010}
	\mauvaise{10110}
	\mauvaise{10011}
	\mauvaise{11010}
	\end{reponses}
	\end{multicols}
\end{question}

\begin{question}{entiers 03} % genumsi nreveret
	Convertir  la valeur décimale 155 en binaire (sur un octet).
	\begin{multicols}{4}
	\begin{reponses}	
	\bonne{10011011}
	\mauvaise{11011011}
	\mauvaise{01111111}
	\mauvaise{10010111}
	\end{reponses}
	\end{multicols}
\end{question}
}

\element{CodageEntiersRelatifs}{
\begin{question}{relatifs 01}% genumsi nreveret
	Quel est l'entier relatif codé en complément à 2 sur un octet par le code 1111 1111 ?
	\begin{multicols}{4}
	\begin{reponses}	
	\bonne{-1}
	\mauvaise{255}
	\mauvaise{127}
	\mauvaise{45}
	\end{reponses}
	\end{multicols}
\end{question}}


\element{CodageHexa}{
\begin{question}{hexa 01} % genumsi nreveret
	Convertir  la valeur décimale 195 en hexadécimal.
	\begin{multicols}{4}
	\begin{reponses}
	\bonne{C3}
	\mauvaise{A5}
	\mauvaise{B9}
	\mauvaise{C9}
	\end{reponses}
	\end{multicols}
\end{question}

\begin{question}{hexa 01}

	\begin{multicols}{4}
	\begin{reponses}	
	\bonne{}
	\mauvaise{}
	\mauvaise{}
	\mauvaise{}
	\end{reponses}
	\end{multicols}
\end{question}
}

\element{AlgebreBoole}{
\begin{question}{boole 01}% genumsi nreveret
	En logique (algèbre de Boole), l'expression: \lstinline{not (A or B)} est équivalente à  :
	\begin{multicols}{4}
	\begin{reponses}	
	\bonne{\lstinline{(not A) and (not B)}}
	\mauvaise{\lstinline{(not A) or (not B)}}
	\mauvaise{\lstinline{A or B}}
	\mauvaise{\lstinline{A and B}}
	\end{reponses}
	\end{multicols}
\end{question}}


\element{ChainesCaracteres}{
\begin{question}{str01} % genumsi nreveret
	On a saisi le code suivant :\lstinline{mot = 'première'}. Quelle affirmation est vraie ?
\begin{multicols}{4}	
	\begin{reponses}	
	\bonne{\lstinline{mot[7]} vaut \lstinline{'e'}}
	\mauvaise{\lstinline{mot[1]} vaut \lstinline{'p'}}
	\mauvaise{\lstinline{len(mot)} vaut 7}
	\mauvaise{\lstinline{len(mot)} vaut 6}
	\end{reponses}
	\end{multicols}
\end{question}


\begin{question}{str}

\begin{multicols}{4}	
	\begin{reponses}	
	\bonne{}
	\mauvaise{}
	\mauvaise{}
	\mauvaise{}
	\end{reponses}
	\end{multicols}
\end{question}
}


\element{}{
\begin{question}{}

\begin{multicols}{4}	
	\begin{reponses}	
	\bonne{}
	\mauvaise{}
	\mauvaise{}
	\mauvaise{}
	\end{reponses}
	\end{multicols}
\end{question}
}



%
%\begin{question}{bin_}
%	\begin{multicols}{4}
%	\begin{reponses}	
%	\bonne{}
%	\mauvaise{}
%	\mauvaise{}
%	\mauvaise{}
%	\end{reponses}
%	\end{multicols}
%\end{question}
%}


	\melangegroupe{OperationsElementaires}
	\restituegroupe{OperationsElementaires}

	\melangegroupe{OperationsArithmetiques}
	\restituegroupe{OperationsArithmetiques}

	\melangegroupe{CodageEntiers}
	\restituegroupe{CodageEntiers}
	
	\melangegroupe{CodageEntiersRelatifs}
	\restituegroupe{CodageEntiersRelatifs}

	\melangegroupe{CodageHexa}
	\restituegroupe{CodageHexa}
	
	\melangegroupe{AlgebreBoole}
	\restituegroupe{AlgebreBoole}

	\melangegroupe{ChainesCaracteres}
	\restituegroupe{ChainesCaracteres}
\end{document}